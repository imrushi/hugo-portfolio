<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>system design on Rushi Panchariya</title><link>/tags/system-design/</link><description>Recent content in system design on Rushi Panchariya</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 24 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>System Design</title><link>/notes/system-design/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>/notes/system-design/</guid><description>Zero To Millions of Users In this section, we will explores the process of scaling a system from supporting a single user to eventually serving millions of users.
Single Server Setup In any system development journey, it&amp;rsquo;s best to begin with a simple step, and that applies even to complex systems. We initiate this process by running everything on a single server. This single server setup includes web services, applications, databases, caching, and more.</description><content>&lt;hr>
&lt;h2 id="zero-to-millions-of-users">Zero To Millions of Users&lt;/h2>
&lt;p>In this section, we will explores the process of scaling a system from supporting a single user to eventually serving millions of users.&lt;/p>
&lt;h3 id="single-server-setup">Single Server Setup&lt;/h3>
&lt;p>In any system development journey, it&amp;rsquo;s best to begin with a simple step, and that applies even to complex systems. We initiate this process by running everything on a single server. This single server setup includes web services, applications, databases, caching, and more.&lt;/p>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/simple-web-server.png" alt="Single Server Setup" style="border-radius: 8px;" />
&lt;figcaption class="center" >Single Web Server Working&lt;/figcaption>
&lt;/figure>
&lt;ol>
&lt;li>User access websites through domain names, such as mysite.dev. Domain Name System (DNS) is a third-party paid service not hosted by our system.&lt;/li>
&lt;li>DNS translates the domain name into an IP address, such as 10.43.23.18 in the figure.&lt;/li>
&lt;li>Once the IP address is obtained, HTTP requests are sent directly to the web server.&lt;/li>
&lt;li>The web server returns HTML pages or JSON response for rendering.&lt;/li>
&lt;/ol>
&lt;p>The traffic to this single server comes from two primary sources:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Web App&lt;/strong>: It utilizes server-side languages (e.g., Java, Go, Python) for business logic and storage, along with client-side languages like HTML and JavaScript for presentation.&lt;/li>
&lt;li>&lt;strong>Mobile App&lt;/strong>: HTTP protocol facilitates communication between the mobile app and the web server. JSON is commonly used for API responses due to its simplicity.&lt;/li>
&lt;/ul>
&lt;h3 id="scaling-with-multiple-servers">Scaling with Multiple Servers&lt;/h3>
&lt;p>As the user base grows, relying on a single server is no longer sufficient. We need to move to a multi-server setup, separating web/mobile traffic from the database. This separation allows for independent scaling of web/mobile traffic servers and database servers.&lt;/p>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/simple-web-server.png" alt="Single Server Setup" style="border-radius: 8px;" />
&lt;figcaption class="center" >Single Web Server with DB&lt;/figcaption>
&lt;/figure>
&lt;h4 id="choosing-the-right-database">Choosing the Right Database&lt;/h4>
&lt;p>When it comes to databases, there are two main categories to consider: Relational Database and Non-Relational Database.&lt;/p>
&lt;p>&lt;strong>&lt;em>Relational Databases&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>These are often referred to as relational database management system (RDBMS) or SQL database.&lt;/li>
&lt;li>Data is structured in tables and rows.&lt;/li>
&lt;li>SQL is used for joining data from different tables.&lt;/li>
&lt;li>Popular databases options: MySQL, PostgresSQL, Oracle database, MSSQL, etc.&lt;/li>
&lt;li>This technology has been around for more than 40 years.&lt;/li>
&lt;/ul>
&lt;p>If relational databases doesn&amp;rsquo;t suit your specific use case, it&amp;rsquo;s essential to explore beyond relational databases.&lt;/p>
&lt;p>&lt;strong>&lt;em>Non-Relational Databases&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Also known as NoSQL databases.&lt;/li>
&lt;li>Categorized into:
&lt;ol>
&lt;li>Key-value stores&lt;/li>
&lt;li>Graph stores&lt;/li>
&lt;li>Column stores&lt;/li>
&lt;li>Document stores&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Typically, non-relational databases do not support join operations.&lt;/li>
&lt;li>Popular databases options: CouchDB, Neo4j, Cassandra, MongoDB, Amazon DynamoDB, etc.&lt;/li>
&lt;li>Non-relational databases might be the right choice if:
&lt;ul>
&lt;li>Requires super-low latency.&lt;/li>
&lt;li>Deal with unstructured data.&lt;/li>
&lt;li>Need to store a massive amount of data.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="scaling-the-database">Scaling the Database&lt;/h4>
&lt;p>There are two ways to scale database: Vertical Scaling and Horizontal Scaling&lt;/p>
&lt;p>&lt;strong>&lt;em>Vertical Scaling&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>This involves adding more power (CPU, RAM, etc.) to your existing servers.&lt;/li>
&lt;li>Vertical scaling is suitable when traffic is low, and its simplicity is an advantage.&lt;/li>
&lt;li>However, it has limitations, including a hard limit on resources and a lack of failover and redundancy.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;em>Horizontal Scaling&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>This approach involves adding more servers to your resource pool.&lt;/li>
&lt;li>It is more suitable for large-scale applications, addressing the limitations of vertical scaling.&lt;/li>
&lt;/ul>
&lt;p>In the previous design, users connected directly to the web server, leading to potential issues like server unavailability or slow responses during high traffic. To address these challenges, load balancing comes into play.&lt;/p>
&lt;h3 id="load-balancer">Load Balancer&lt;/h3>
&lt;p>Load balancers distribute incoming traffic evenly among a set of web servers defined in a load-balanced configuration.&lt;/p>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/load-balancer.png" alt="Single Server Setup" style="border-radius: 8px;" />
&lt;figcaption class="center" >Single Web Server Working&lt;/figcaption>
&lt;/figure>
&lt;p>As shown in above diagram:&lt;/p>
&lt;ul>
&lt;li>Users connect to the public IP of the load balancer directly.&lt;/li>
&lt;li>The load balancer then directs the request to one of the web servers via a private IP for enhanced security.&lt;/li>
&lt;li>Private IPs are used for server-to-server communication within the same network.&lt;/li>
&lt;/ul>
&lt;p>This setup resolves the issue of server unavailability and enhances web tier availability. For instance:&lt;/p>
&lt;ul>
&lt;li>If one server goes offline, traffic is automatically redirected to another server, preventing downtime.&lt;/li>
&lt;li>As website traffic grows, additional servers can be added to the pool, and the load balancer will distribute requests accordingly.&lt;/li>
&lt;/ul>
&lt;p>The current design includes a single database, which lacks failover and redundancy. To address this, let&amp;rsquo;s explore database replication.&lt;/p>
&lt;h3 id="database-replication">Database Replication&lt;/h3>
&lt;p>Database replication involves establishing a master-slave relationship between the master and the slave databases.&lt;/p>
&lt;ul>
&lt;li>The master database primarily handles write operations.&lt;/li>
&lt;li>Slave databases replicate data from the master but are typically reserved for read operations.&lt;/li>
&lt;li>Any data-modifying commands, such as insertions, deletions, or updates, are directed to the master database.&lt;/li>
&lt;li>Most application requires a much higher ratio of reads to writes; thus, the number of slave db in system usually larger than the number of master db.&lt;/li>
&lt;/ul>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/db-replication.png" alt="Database Replication" style="border-radius: 8px;" />
&lt;figcaption class="center" >Database Replication&lt;/figcaption>
&lt;/figure>
&lt;p>Advantages of database replication:&lt;/p>
&lt;ul>
&lt;li>Enhanced Performance: In a master-slave model, the master handles write and update operations, while read tasks are efficiently distributed to slave nodes, improving query processing performance.&lt;/li>
&lt;li>Reliability: Data is preserved, even in the event of natural disasters, preventing data loss. We do not need to worry about data loss because data is replicated across multiple locations.&lt;/li>
&lt;li>High availability: Even if one server breaks, the website continues to function, using data from another server, ensuring smooth operation.&lt;/li>
&lt;/ul>
&lt;h4 id="what-if-one-of-the-databases-goes-offline">What if one of the databases goes offline?&lt;/h4>
&lt;ul>
&lt;li>If there&amp;rsquo;s only one slave database available, and it experiences an outage, read operations will temporarily shift to the master database. As soon as the issue is detected, a new slave database will replace the faulty one. In cases where multiple slave databases are in operations, read operations are rerouted to other healthy slave databases. A new database server will promptly replace the problematic one.&lt;/li>
&lt;li>In the event of the master database going offline, one of the slave databases will be promoted to assume the role of the new master. All database operations will be temporarily executed on this newly appointed master database. Simultaneously, a new slave database will be introduced to ensure data replication continues seamlessly.&lt;/li>
&lt;/ul>
&lt;p>In practical production systems, promoting a new master is more intricate, as the data in a slave database may not be up-to-date. This necessitates the execution of data recovery script to reconcile the missing data. Although alternative replication methods such as multi-master and circular replication exist, they tend to be more intricate in nature.&lt;/p>
&lt;p>Let&amp;rsquo;s examine the system design:&lt;/p>
&lt;ul>
&lt;li>When a user wants to access the system, they obtain the IP address of the load balancer via DNS.&lt;/li>
&lt;li>Using this IP address, the user establishes a connection with the load balancer.&lt;/li>
&lt;li>The load balancer routes the HTTP request to either Server 1 or Server 2.&lt;/li>
&lt;li>A web server retrieves user data from slave database.&lt;/li>
&lt;li>Any data-modifying operations, such as write, update, or delete actions, are directed to the master database.&lt;/li>
&lt;/ul>
&lt;p>With understanding of the web and data tiers, the next step is to enhance the systems&amp;rsquo;s response time. This can be achieved by introducing a cache layer and transferring static content like JavaScript, CSS, Images, and Video files to a content delivery network (CDN).&lt;/p>
&lt;h2 id="cache">Cache&lt;/h2>
&lt;p>A cache is a temporary storage. It stores frequently accessed data in memory so that requests are served more quickly. Whenever web page loads, one or more database call are executed to fetch data. It highly impact the performance of the application by calling the database repeatedly. The cache can mitigate this problem.&lt;/p>
&lt;p>Cache tier is a temporary data store layer, much faster that the database. Having a separate cache tier benefits the:&lt;/p>
&lt;ul>
&lt;li>System Performance&lt;/li>
&lt;li>Reduce Database Workloads&lt;/li>
&lt;li>Scale the Cache Tire Independently&lt;/li>
&lt;/ul>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/cache-tier.png" alt="Cache tier" style="border-radius: 8px;" />
&lt;figcaption class="center" >Setup of cache server&lt;/figcaption>
&lt;/figure>
&lt;p>After receiving a request:&lt;/p>
&lt;ol>
&lt;li>Web server checks if data exists in cache.&lt;/li>
&lt;li>If exists it returns the data.&lt;/li>
&lt;li>If not exists, it queries database for data, and save the response data in cache and send it back to client.&lt;/li>
&lt;li>This caching strategy is called a read-through cache.&lt;/li>
&lt;/ol>
&lt;p>Caching strategy depends on the data and &lt;strong>&lt;em>data access patterns&lt;/em>&lt;/strong>.&lt;/p>
&lt;p>Below are Caching Strategies:&lt;/p>
&lt;h3 id="cache-aside">Cache-Aside&lt;/h3>
&lt;ul>
&lt;li>Application directly talks to both the cache and the database.&lt;/li>
&lt;li>No connection between the cache and the database.&lt;/li>
&lt;li>All operations to cache and database are handled by the application.&lt;/li>
&lt;/ul>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/cache-aside.png" alt="Cache Aside" style="border-radius: 8px;" />
&lt;figcaption class="center" >Cache Aside&lt;/figcaption>
&lt;/figure>
&lt;p>Here is what happing:&lt;/p>
&lt;ol>
&lt;li>When the application need data, it first checks the cache for the data.&lt;/li>
&lt;li>If the data is not found in the cache (a cache miss), the application fetches the data from the primary data store (eg. a database).&lt;/li>
&lt;li>After fetching the data, the application insert or updates it in the cache, associating it with a specific key. The update can be synchronous or asynchronous, depending on the design.&lt;/li>
&lt;li>The application uses the data from the cache for subsequent read requests until the data expires or is invalidated.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>&lt;em>Pros&lt;/em>&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Read-Heavy Workloads&lt;/strong>: Cache-Aside is well-suited for read-heavy workloads, efficiently reducing the load on the primary database.&lt;/li>
&lt;li>&lt;strong>Resilience to Cache Failures&lt;/strong>: Systems using Cache-Aside remain operational even if the cache cluster fails since they can directly access the database. This provide resilience and ensure system availability.&lt;/li>
&lt;li>&lt;strong>Flexible Data Models&lt;/strong>: Cache-Aside allows for different data models in the cache compared to the database. It&amp;rsquo;s versatile for storing responses resulting from multiple queries against a request ID.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>&lt;em>Cons&lt;/em>&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Data Inconsistency&lt;/strong>: When data is written to the database, the cache may become inconsistent. Developers often rely on Time to Live (TTL) to serve stale data, but this can lead to inconsistencies and issues with data freshness.&lt;/li>
&lt;li>&lt;strong>Stale Data&lt;/strong>: In cases where TTL is used, there&amp;rsquo;s a risk of serving stale data until the expiration, which might not be suitable for applications requiring up-to-date information.&lt;/li>
&lt;li>&lt;strong>Lack of Cache Consistency&lt;/strong>: Cache-Aside doesn&amp;rsquo;t guarantee cache consistency, potentially resulting in multiple clients fetching and updating the same data simultaneously. This can lead to data inconsistency.&lt;/li>
&lt;li>&lt;strong>Peak Load Issues&lt;/strong>: If the cache fails during peak loads, response times can get worse(deteriorate), and in extreme cases, it might even overwhelm the database, impacting system performance.&lt;/li>
&lt;/ol>
&lt;p>We can read Cache strategy here: &lt;a href="https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/">https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/&lt;/a>&lt;/p></content></item></channel></rss>