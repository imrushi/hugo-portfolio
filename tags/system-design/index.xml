<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>system design on Rushi Panchariya</title><link>/tags/system-design/</link><description>Recent content in system design on Rushi Panchariya</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 24 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/system-design/index.xml" rel="self" type="application/rss+xml"/><item><title>System Design</title><link>/notes/system-design/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>/notes/system-design/</guid><description>Zero To Millions of Users In this section, we will explores the process of scaling a system from supporting a single user to eventually serving millions of users.
Single Server Setup In any system development journey, it&amp;rsquo;s best to begin with a simple step, and that applies even to complex systems. We initiate this process by running everything on a single server. This single server setup includes web services, applications, databases, caching, and more.</description><content>&lt;hr>
&lt;h2 id="zero-to-millions-of-users">Zero To Millions of Users&lt;/h2>
&lt;p>In this section, we will explores the process of scaling a system from supporting a single user to eventually serving millions of users.&lt;/p>
&lt;h3 id="single-server-setup">Single Server Setup&lt;/h3>
&lt;p>In any system development journey, it&amp;rsquo;s best to begin with a simple step, and that applies even to complex systems. We initiate this process by running everything on a single server. This single server setup includes web services, applications, databases, caching, and more.&lt;/p>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/simple-web-server.png" alt="Single Server Setup" style="border-radius: 8px;" />
&lt;figcaption class="center" >Single Web Server Working&lt;/figcaption>
&lt;/figure>
&lt;ol>
&lt;li>User access websites through domain names, such as mysite.dev. Domain Name System (DNS) is a third-party paid service not hosted by our system.&lt;/li>
&lt;li>DNS translates the domain name into an IP address, such as 10.43.23.18 in the figure.&lt;/li>
&lt;li>Once the IP address is obtained, HTTP requests are sent directly to the web server.&lt;/li>
&lt;li>The web server returns HTML pages or JSON response for rendering.&lt;/li>
&lt;/ol>
&lt;p>The traffic to this single server comes from two primary sources:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Web App&lt;/strong>: It utilizes server-side languages (e.g., Java, Go, Python) for business logic and storage, along with client-side languages like HTML and JavaScript for presentation.&lt;/li>
&lt;li>&lt;strong>Mobile App&lt;/strong>: HTTP protocol facilitates communication between the mobile app and the web server. JSON is commonly used for API responses due to its simplicity.&lt;/li>
&lt;/ul>
&lt;h3 id="scaling-with-multiple-servers">Scaling with Multiple Servers&lt;/h3>
&lt;p>As the user base grows, relying on a single server is no longer sufficient. We need to move to a multi-server setup, separating web/mobile traffic from the database. This separation allows for independent scaling of web/mobile traffic servers and database servers.&lt;/p>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/simple-web-server.png" alt="Single Server Setup" style="border-radius: 8px;" />
&lt;figcaption class="center" >Single Web Server with DB&lt;/figcaption>
&lt;/figure>
&lt;h4 id="choosing-the-right-database">Choosing the Right Database&lt;/h4>
&lt;p>When it comes to databases, there are two main categories to consider: Relational Database and Non-Relational Database.&lt;/p>
&lt;p>&lt;strong>&lt;em>Relational Databases&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>These are often referred to as relational database management system (RDBMS) or SQL database.&lt;/li>
&lt;li>Data is structured in tables and rows.&lt;/li>
&lt;li>SQL is used for joining data from different tables.&lt;/li>
&lt;li>Popular databases options: MySQL, PostgresSQL, Oracle database, MSSQL, etc.&lt;/li>
&lt;li>This technology has been around for more than 40 years.&lt;/li>
&lt;/ul>
&lt;p>If relational databases doesn&amp;rsquo;t suit your specific use case, it&amp;rsquo;s essential to explore beyond relational databases.&lt;/p>
&lt;p>&lt;strong>&lt;em>Non-Relational Databases&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Also known as NoSQL databases.&lt;/li>
&lt;li>Categorized into:
&lt;ol>
&lt;li>Key-value stores&lt;/li>
&lt;li>Graph stores&lt;/li>
&lt;li>Column stores&lt;/li>
&lt;li>Document stores&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Typically, non-relational databases do not support join operations.&lt;/li>
&lt;li>Popular databases options: CouchDB, Neo4j, Cassandra, MongoDB, Amazon DynamoDB, etc.&lt;/li>
&lt;li>Non-relational databases might be the right choice if:
&lt;ul>
&lt;li>Requires super-low latency.&lt;/li>
&lt;li>Deal with unstructured data.&lt;/li>
&lt;li>Need to store a massive amount of data.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="scaling-the-database">Scaling the Database&lt;/h4>
&lt;p>There are two ways to scale database: Vertical Scaling and Horizontal Scaling&lt;/p>
&lt;p>&lt;strong>&lt;em>Vertical Scaling&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>This involves adding more power (CPU, RAM, etc.) to your existing servers.&lt;/li>
&lt;li>Vertical scaling is suitable when traffic is low, and its simplicity is an advantage.&lt;/li>
&lt;li>However, it has limitations, including a hard limit on resources and a lack of failover and redundancy.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;em>Horizontal Scaling&lt;/em>&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>This approach involves adding more servers to your resource pool.&lt;/li>
&lt;li>It is more suitable for large-scale applications, addressing the limitations of vertical scaling.&lt;/li>
&lt;/ul>
&lt;p>In the previous design, users connected directly to the web server, leading to potential issues like server unavailability or slow responses during high traffic. To address these challenges, load balancing comes into play.&lt;/p>
&lt;h3 id="load-balancer">Load Balancer&lt;/h3>
&lt;p>Load balancers distribute incoming traffic evenly among a set of web servers defined in a load-balanced configuration.&lt;/p>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/load-balancer.png" alt="Single Server Setup" style="border-radius: 8px;" />
&lt;figcaption class="center" >Single Web Server Working&lt;/figcaption>
&lt;/figure>
&lt;p>As shown in above diagram:&lt;/p>
&lt;ul>
&lt;li>Users connect to the public IP of the load balancer directly.&lt;/li>
&lt;li>The load balancer then directs the request to one of the web servers via a private IP for enhanced security.&lt;/li>
&lt;li>Private IPs are used for server-to-server communication within the same network.&lt;/li>
&lt;/ul>
&lt;p>This setup resolves the issue of server unavailability and enhances web tier availability. For instance:&lt;/p>
&lt;ul>
&lt;li>If one server goes offline, traffic is automatically redirected to another server, preventing downtime.&lt;/li>
&lt;li>As website traffic grows, additional servers can be added to the pool, and the load balancer will distribute requests accordingly.&lt;/li>
&lt;/ul>
&lt;p>The current design includes a single database, which lacks failover and redundancy. To address this, let&amp;rsquo;s explore database replication.&lt;/p>
&lt;h3 id="database-replication">Database Replication&lt;/h3>
&lt;p>Database replication involves establishing a master-slave relationship between the master and the slave databases.&lt;/p>
&lt;ul>
&lt;li>The master database primarily handles write operations.&lt;/li>
&lt;li>Slave databases replicate data from the master but are typically reserved for read operations.&lt;/li>
&lt;li>Any data-modifying commands, such as insertions, deletions, or updates, are directed to the master database.&lt;/li>
&lt;li>Most application requires a much higher ratio of reads to writes; thus, the number of slave db in system usually larger than the number of master db.&lt;/li>
&lt;/ul>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/db-replication.png" alt="Database Replication" style="border-radius: 8px;" />
&lt;figcaption class="center" >Database Replication&lt;/figcaption>
&lt;/figure>
&lt;p>Advantages of database replication:&lt;/p>
&lt;ul>
&lt;li>Enhanced Performance: In a master-slave model, the master handles write and update operations, while read tasks are efficiently distributed to slave nodes, improving query processing performance.&lt;/li>
&lt;li>Reliability: Data is preserved, even in the event of natural disasters, preventing data loss. We do not need to worry about data loss because data is replicated across multiple locations.&lt;/li>
&lt;li>High availability: Even if one server breaks, the website continues to function, using data from another server, ensuring smooth operation.&lt;/li>
&lt;/ul>
&lt;h1 id="cache">Cache&lt;/h1>
&lt;p>A cache is a temporary storage. It stores frequently accessed data in memory so that requests are served more quickly. Whenever web page loads, one or more database call are executed to fetch data. It highly impact the performance of the application by calling the database repeatedly. The cache can mitigate this problem.&lt;/p>
&lt;p>Cache tier is a temporary data store layer, much faster that the database. Having a separate cache tier benefits the:&lt;/p>
&lt;ul>
&lt;li>System Performance&lt;/li>
&lt;li>Reduce Database Workloads&lt;/li>
&lt;li>Scale the Cache Tire Independently&lt;/li>
&lt;/ul>
&lt;figure class="center" >
&lt;img src="/img/notes/system-design/cache-tier.png" alt="Cache tier" style="border-radius: 8px;" />
&lt;figcaption class="center" >Setup of cache server&lt;/figcaption>
&lt;/figure>
&lt;p>After receiving a request:&lt;/p>
&lt;ol>
&lt;li>Web server checks if data exists in cache.&lt;/li>
&lt;li>If exists it returns the data.&lt;/li>
&lt;li>If not exists, it queries database for data, and save the response data in cache and send it back to client.&lt;/li>
&lt;li>This caching strategy is called a read-through cache.&lt;/li>
&lt;/ol>
&lt;p>Caching strategy depends on the data and &lt;strong>&lt;em>data access patterns&lt;/em>&lt;/strong>.&lt;/p>
&lt;p>Below are Caching Strategies:&lt;/p>
&lt;h2 id="cache-aside">Cache-Aside&lt;/h2>
&lt;ul>
&lt;li>Application directly talks to both the cache and the database.&lt;/li>
&lt;li>No connection between the cache and the database.&lt;/li>
&lt;li>All operations to cache and database are handled by the application.&lt;/li>
&lt;/ul>
&lt;p>We can read Cache strategy here: &lt;a href="https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/">https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/&lt;/a>&lt;/p></content></item></channel></rss>