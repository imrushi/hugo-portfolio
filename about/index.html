<!doctype html><html lang=en><head><title>About :: Rushi Panchariya</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Hi there Hello, I am Rushi Panchariya. I&amp;rsquo;m Software Engineer with passion for Gaming üéÆ, Coding üë®‚Äçüíª and Music üéß.
I&amp;rsquo;m always excited to work on new technologies and learn more about them. I am excited to work on a project that will benefit the community and assist them address their difficulties in whatever manner possible. When I&amp;rsquo;m working on a project, a concept, or a task, I&amp;rsquo;m always intrigued about the outcome."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/about/><script async src="https://www.googletagmanager.com/gtag/js?id=G-P4ZXCNLZ0R"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-P4ZXCNLZ0R",{anonymize_ip:!1})}</script><link rel=stylesheet href=/styles.css><link rel=stylesheet href=/style.css><link rel="shortcut icon" href=/img/theme-colors/blue.png><link rel=apple-touch-icon href=/img/theme-colors/blue.png><meta name=twitter:card content="summary"><meta name=twitter:site content="RushiPanchariya"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="About"><meta property="og:description" content="Hi there Hello, I am Rushi Panchariya. I&amp;rsquo;m Software Engineer with passion for Gaming üéÆ, Coding üë®‚Äçüíª and Music üéß.
I&amp;rsquo;m always excited to work on new technologies and learn more about them. I am excited to work on a project that will benefit the community and assist them address their difficulties in whatever manner possible. When I&amp;rsquo;m working on a project, a concept, or a task, I&amp;rsquo;m always intrigued about the outcome."><meta property="og:url" content="/about/"><meta property="og:site_name" content="Rushi Panchariya"><meta property="og:image" content="/img/favicon/blue.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"></head><body class=blue><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Rushi Panchariya</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;‚ñæ</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/projects>Projects</a></li><li><a href=/notes>Notes</a></li><li><a href=https://drive.google.com/file/d/1bwr2HSwIqLUBurvUA94q_D2xQR4lpjP1/view>Resume</a></li><li><a href=https://archive.ruship.dev>Archive site</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/projects>Projects</a></li><li><a href=/notes>Notes</a></li><li><a href=https://drive.google.com/file/d/1bwr2HSwIqLUBurvUA94q_D2xQR4lpjP1/view>Resume</a></li><li><ul class=menu><li class=menu__trigger>Show more&nbsp;‚ñæ</li><li><ul class=menu__dropdown><li><a href=https://archive.ruship.dev>Archive site</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/about/>About</a></h1><div class=post-meta></div><div class=post-content><div><h1 id=hi-there-hahahugoshortcode5s0hbhb>Hi there
<img src=/img/pikachu-running.gif class=left style=width:50px></h1><p>Hello, I am Rushi Panchariya. I&rsquo;m <strong>Software Engineer</strong> with passion for Gaming üéÆ, Coding üë®‚Äçüíª and Music üéß.</p><p>I&rsquo;m always excited to work on new technologies and learn more about them. I am excited to work on a project that will benefit the community and assist them address their difficulties in whatever manner possible. When I&rsquo;m working on a project, a concept, or a task, I&rsquo;m always intrigued about the outcome.</p><p>Feel free to visit my <a href=https://github.com/imrushi>GitHub</a>.</p><p>So, there you have it&mldr; enjoy!</p></div></div></article></div><script>window.store={"/posts/create-github-action/":{title:"Automate with Precision: Building Custom GitHub Actions",tags:["github","actions","ci/cd","docker","go"],categories:["GitHub"],keywords:["GitHub Actions","Docker Container Action","Custom GitHub Actions","GitHub Workflow","GitHub Marketplace","YAML Workflow","Dockerfile for Actions","GitHub Automation","Publish GitHub Action","GitHub Action Testing"],content:`After writing my Go Dash blog, I got an idea of whether I could push the same blog to Medium. I started looking for ways to automate this thing. I checked on the GitHub Marketplace for actions that can push content to Medium directly. I found the GitHub action hugo-to-medium by Prakhar Kaushik.
This GitHub action was good, but there were some issues. In Hugo, I mostly use shortcodes to showcase the sample codes, figures, and images. Another one is that it doesn‚Äôt remove any shortcodes. There was no way for me to remove this from the publishing process. So this issue inspired me to create my own GitHub action, which allows to:
Select and replace shortcodes using regex. Remove the frontmatter of YAML, TOML, or JSON formats from the post. Extract the title and tag from the frontmatter. Support both Markdown and Hugo Markdown formats. TL;DR: If you want to start creating a GitHub action without a backstory, head over to the Creating a GitHub Action section.
While I was researching on how to create my own or custom GitHub actions, I started with the GitHub documentation - it was straight-forward; there were a few steps, but there are three ways to create GitHub Actions:
Docker container action:
It packages the entire environment needed for GitHub Actions. They bundle not only your code but also the specific OS, dependencies, tools, and runtime environment. This packaging approach ensures consistency and reliability because the consumers of your action don&rsquo;t need to worry about installing the necessary tools or dependencies themselves. It tends to be slower than JavaScript action due to the time it takes to build and retrieve the container. It can only execute on a Linux based operating system. If you&rsquo;re using self-hosted runners1, they must also be running a Linux based operating system and have Docker installed to execute Docker container actions. JavaScript action:
It runs directly on the runner1 machine. These actions separate your action&rsquo;s code from the environment used to run that code. It ensure compatibility with all GitHub-hosted runners1 (including Ubuntu, Windows, and macOS). It uses pure JavaScript and existing runner binaries. GitHub Actions Toolkit offers Node.js packages for faster development. Composite action:
Composite actions combine multiple workflow steps into one action. Say you have several run commands that you frequently use together in your workflows. With composite actions, you can bundle these commands into a single, well-defined action. It simplifies workflows by creating reusable actions. Using this composite action in your workflow makes your workflow configuration cleaner and more maintainable. It is great for organizing complex workflows efficiently. Before we start, let&rsquo;s check what mistakes I have made so you can avoid these mistakes.
Mistakes were made Be clear about what you want to achieve. When I read the documentation, I was not clear about which action type I should use. I thought composite action would be the perfect option for me. Let me explain why.
I am thinking it will be straight forward that:
I will write code or logic in Go Build the program binary with the Linux AMD64 option. At the time of release, add it to the Assets of GitHub Releases. When action runs, it will fetch a binary from assets. Using that binary, I will pass the required arguments. The program will handle everything and post content to Medium. But when I have written everything for actions, The program is working as expected and passing unit test cases. I thought now I had to create action.yml with composite action and take all inputs and pass them to the binary. I am happy and excited to test it üòÅ.
As expected, it is not going to run on the first try. I got some errors; actions were not able to fetch the binary (I wrote a script for that). To solve this issue, I removed the script and placed the Go action step, which will directly install Go in the system. Then I can build a binary and execute it. It sounds simple, so the actions are as follows:
yaml action.yml name: &#34;Markdown Or Hugo To Medium&#34; description: &#34;Push hugo markdown post to medium&#34; # declaring input variables for workflow inputs: markdownOrHugo: description: &#34;Specify is it Markdown or Hugo Markdown&#34; required: true default: markdown shortcodes: description: &#34;Shortcodes JSON config file location&#34; required: false replaceHyperlinkToLink: description: &#34;Replace hyperlink to link for medium cards&#34; required: false default: false frontmatterFormat: description: &#34;Select frontmatter format [yaml, toml]&#34; required: false default: &#34;yaml&#34; draft: description: &#34;Publish as a draft on Medium&#34; required: false default: false # running steps runs: using: &#34;composite&#34; steps: - name: Install jq run: sudo apt-get update &amp;&amp; sudo apt-get install -y jq shell: bash - name: Check out the repository to the runner uses: actions/checkout@v4 - name: Setup Go 1.21.x uses: actions/setup-go@v4 with: go-version: &#39;1.21.x&#39; - name: Install dependencies and Build run: | cd \${{ github.action_path }} &amp;&amp; \\ go get . &amp;&amp; \\ go build -o HugoToMedium main.go &amp;&amp; \\ ./HugoToMedium \\ -markdown-or-hugo=\${{ inputs.markdownOrHugo }} \\ -shortcodes-config-file=\${{ inputs.shortcodes }} \\ -replace-hyperlink-to-link=\${{ inputs.replaceHyperlinkToLink }} \\ -frontmatter=\${{ inputs.frontmatterFormat }} \\ -draft=\${{ inputs.draft }} shell: bash # it will be used in GitHub Marketplace next to action name branding: icon: &#34;book-open&#34; color: &#34;blue&#34; This time, I thought everything looked good. But I was getting this error: FATA[2023-09-29T11:17:24Z] repository does not exist - it was generated from binary; it was not able to find the .git directory. I was using it to take the latest commit message.
The conclusion for me was that I was not going to use the composite actions. Now I have two options:
JavaScript actions Docker actions If I use JavaScript actions, I will have to write my logic again in JavaScript, which I have written in Go. So I decided to use Docker Action, which was easy to implement.
Just need to write Dockerfile and update action.yml.
What I learn from this mistake is that I will have to do proper planning next time ü§û.
Let&rsquo;s check out how to create custom GitHub actions. In this, I am going to create Docker actions, but action.yml will have an almost similar syntax.
Creating a GitHub Action As we are creating Docker actions, we need to write a Dockerfile. In your project root directory, create a new Dockerfile file. Make sure that your filename is capitalized correctly. D should be capitalized, as shown above. We will be writing it for my markdown-or-hugo-to-medium.
docker Dockerfile FROM golang:1.21.1-alpine3.18 RUN apk add git COPY . /home/src WORKDIR /home/src RUN GOOS=linux GOARCH=amd64 go build -o HugoToMedium main.go RUN chmod &#43;x HugoToMedium ENTRYPOINT [ &#34;/home/src/HugoToMedium&#34; ] What is going on in the above Dockerfile:
We are pulling golang:1.21.1 alpine image Installing git because if a program is required Copying all the required local files into the /home/src folder of the container Changing Working Directory In this golang:1.21.1 alpine image, golang is already installed. We will use that to build out a binary for the Linux OS with the AMD64 architecture. Update the file permissions to execute. After building the image, when it runs, it should directly run the binary, so we have added the ENTRYPOINT for that. If you want to know more about the Dockerfile instructions for GitHub Action, check out this Document.
Creating Action File Create a new action.yml file in the root directory of your project. This action file will contain what inputs we should get, what the output should be, and what it should run
There are 7 basic parameters:
name* : It will be used to display the name in the Actions tab. author: Name of the action&rsquo;s author. description* : A short description of the action. input: It allows you to specify the data that the action expects to use during runtime. input.&lt;input_id&gt;* : A string identifier to associate with the input. It should be a unique identifier. description* : A string description of the input parameter. required: A boolean to indicate whether the action requires the input parameter. default: A string representing the default value. deprecationMessage: If the input parameter is used, this string is logged as a warning message. You can use this warning to notify users that the input is deprecated and mention any alternatives. output: It allows you to declare data that an action sets. Actions that run later in a workflow can use the output data set of previously run actions. runs*: It specifies whether this is a JavaScript action, a composite action, or a Docker container action and how the action is executed. This is just an overview of the parameters; what are they? For more information, you can check out these parameters in detail on GitHub Docs.
Below is a sample action.yml for Docker actions:
yaml action.yml name: &#34;Markdown Or Hugo To Medium&#34; description: &#34;Push hugo markdown post to medium&#34; # input variables for data that the action expects at runtime inputs: markdownOrHugo: description: &#34;Specify is it Markdown or Hugo Markdown&#34; required: true default: markdown shortcodes: description: &#34;Shortcodes JSON config file location&#34; required: false replaceHyperlinkToLink: description: &#34;Replace hyperlink to link for medium cards&#34; required: false default: false frontmatterFormat: description: &#34;Select frontmatter format [yaml, toml]&#34; required: false default: &#34;yaml&#34; draft: description: &#34;Publish as a draft on Medium&#34; required: false default: false # configuration to run action runs: using: &#34;docker&#34; image: &#34;Dockerfile&#34; # passing above inputs as argument to program args: - -markdown-or-hugo=\${{ inputs.markdownOrHugo }} - -shortcodes-config-file=\${{ inputs.shortcodes }} - -replace-hyperlink-to-link=\${{ inputs.replaceHyperlinkToLink }} - -frontmatter=\${{ inputs.frontmatterFormat }} - -draft=\${{ inputs.draft }} branding: icon: &#34;book-open&#34; color: &#34;blue&#34; In the above action.yml file, I have specified name which will be used to show in the Actions tab. On the next line, description what it does. I am taking five inputs, each of which starts with a variable name where the input will be stored. For instance, markdown-or-hugo has its own description of what the variable is or, along with whether this variable should be required or optional, and also sets the default value to it. The same is done for the other four inputs.
In the runs section with using parameter, we specify which type of actions we are using docker, and we also have to configure which image to use. If you specify Dockerfile as a value, it will build a docker image and then use it. You can also directly use public Docker registry containers by specifying docker://image-name:tag. If your program takes arguments, you can pass them with the args parameter, and if you want to pass the above-taken input you can use \${{ inputs.input_variable_name }}.
I don&rsquo;t want to store anything for the output variable. So, I haven&rsquo;t used the output parameter, but if you want to show something you can do like this:
yaml outputs: output_parameter: description: &#39;This will show the output which will be set from container&#39; Note that if we want to use this approach, we need to update the Dockerfile, and Entrypoint will be a shell script. From that shell script, we can set the output variable.
bash entrypoint.sh #!/bin/sh # Run your Go program and set GITHUB_OUTPUT program_input=$(your_go_program) # Set the output variable echo &#34;output_parameter=$program_input&#34; &gt;&gt; $GITHUB_OUTPUT You can check out more about the output here.
branding uses icons and colors to create a badge to personalize and distinguish your action. Badges are shown next to your action name in the GitHub Marketplace. You can find the icon here.
Here you have written your first custom github action.
Testing the GitHub Action Before we publish our GitHub Action, we need to test it. It is strange that there is no way to test this GitHub action locally. I think GitHub should have provided something from which we can easily test this.
At the time of testing, I faced some problems and wasn&rsquo;t able to understand the testing document properly. So I took the wrong way, published the action, and then tested it. Please avoid these mistakes.
There are two ways to test it:
If your repository is public, you can test it by assigning uses with &lt;username&gt;/&lt;repo-name&gt;@&lt;branch-name&gt; in steps. With this method, you can test actions in other repositories as well. This workflow YAML should be located at .github/workflows/filename.yml. yaml .github/workflows/publish-medium.yml on: [push] jobs: hello_world_job: runs-on: ubuntu-latest name: A job to say hello steps: - name: test action step # uses an action from given repo uses: imrushi/markdown-or-hugo-to-medium@main with: markdown-or-hugo: &#39;hugo&#39; shortcodes: &#34;./shortcodes.json&#34; replaceHyperlinkToLink: false frontmatterFormat: &#34;yaml&#34; draft: true Second way is to test it in the current repository, you can use ./ in uses. ./ syntax to use an action available in the same repository. This option will work on both public and private repositories. yaml .github/workflows/publish-medium.yml on: [push] jobs: hello_world_job: runs-on: ubuntu-latest name: A job to say hello steps: - name: test action step # Uses an action in the root directory uses: ./ with: markdown-or-hugo: &#39;hugo&#39; shortcodes: &#34;./shortcodes.json&#34; replaceHyperlinkToLink: false frontmatterFormat: &#34;yaml&#34; draft: true Publishing the GitHub Action As soon as our action has been tested, it&rsquo;s time to publish it. Let&rsquo;s see how we can do that.
To publish GitHub Action to the GitHub Marketplace, your action repository should be public. Follow the below steps to make it public:
First, create a git tag with the version as per semver. git tag -a v1.0.0 -m &quot;release message&quot;
Push the tag to the GitHub repo. git push origin v1.0.0
On the GitHub repository, go to Releases -&gt; Create/Draft a new release.
Mark with ‚úîÔ∏è Publish this Action to the GitHub Marketplace. It also shows if the required things are done or not. Select the primary category and another category. Choose a tag -&gt; select v1.0.0 Give Release title -&gt; v1.0.0 Provide Release Notes. If you want to provide any assets, drag and drop in the box. If your action is not production-ready, mark ‚úîÔ∏è Set as a pre-release. ‚úîÔ∏è Set as the latest release If everything looks good, Hit the Publish release button. Congratulations! üéâ Your action is now available on the GitHub Marketplace!
How to Use the GitHub Action Start by creating a workflow in the .github/workflows directory of your repository (or create the directory if it doesn&rsquo;t exist). Create a YAML file (e.g., main.yml) to define your workflow. Here&rsquo;s an example of a workflow that uses the &ldquo;Markdown Or Hugo To Medium&rdquo; action yaml main.yml on: push: branches: - main jobs: publish-to-medium: runs-on: ubuntu-latest env: POST_DIR: &#34;content/posts&#34; ACCESS_TOKEN: \${{ secrets.MEDIUM_ACCESS_TOKEN }} steps: - name: Checkout Code uses: actions/checkout@v2 # using published GitHub Actions - name: Markdown Or Hugo To Medium uses: imrushi/markdown-or-hugo-to-medium@v1.0.0 # providing inputs to the actions with: markdownOrHugo: &#34;hugo&#34; shortcodes: &#34;./shortcodes.json&#34; replaceHyperlinkToLink: false frontmatterFormat: &#34;yaml&#34; draft: true This workflow is configured to run when changes are pushed to the main branch. It checks out your code, and then it uses the &ldquo;Markdown Or Hugo To Medium&rdquo; action, passing the necessary inputs as specified in the with section.
Commit this workflow YAML file to your repository. Your workflow will now be automatically triggered when you push changes to the main branch. That&rsquo;s it! You&rsquo;ve successfully created, published, and used your custom GitHub Action.
Conclusion In this blog post, we saw how to create a GitHub action using Docker containers. It covers how to prepare and use a Dockerfile and action.yml for GitHub actions.
This blog is about my experience, the mistakes I have made while creating my first GitHub action. I will be creating more GitHub actions for my use cases. You can check them out on my GitHub profile here.
I hope this blog will help you in making your first GitHub action. If you have any questions, please let me know in the comment section. If you find anything new in this blog, share it with others, and if you find any mistakes in it, please let me know and help me make it better. I will definitely fix it.
Thanks for reading! üòä
&ldquo;Runner&rdquo; refers to a virtual machine or container environment where your GitHub Action workflows are executed.&#160;&#x21a9;&#xfe0e;&#160;&#x21a9;&#xfe0e;&#160;&#x21a9;&#xfe0e;
`,url:"/posts/create-github-action/"},"/posts/":{title:"Posts",tags:[],categories:[],keywords:[],content:"",url:"/posts/"},"/posts/go-basics-and-a-dash-of-clean-code/":{title:"Go: Basics and a Dash of Clean Code",tags:["go","basics","clean code"],categories:["Go"],keywords:["go","golang","basics of go","clean code","go syntax","go programming for beginners","go programming tips","learning go","go programming","writing clean code in go","history of go","no semicolon","formatting","comments","names","variables","go tips"],content:` If you have read my first blog Let&rsquo;s Go, which is not about the Go programming language, go check it out üòÖ. You can easily tell how much I am obsessed with the Go programming language. After writing my first blog, I have done some thinking, like where to start my Go programming series blog. I have done some research and collected some notes.
As you read the heading of the blog, I will cover some of the basics that I think are important for anyone starting a programming language that also follows some of the principles of clean code. The topics that I have covered in this blog are the effective way you write your Go code and questions that arise in my mind when I have studied Golang, like why there are different types of variable declarations. Why have they created the Go programming language?
Let&rsquo;s find the answer&rsquo;s:
History of Go The Google search engine experienced an issue back in 2007.
Programs containing millions of lines of code needed to be maintained. Before they could experiment with any new code changes, they had to compile the program, which took them about an hour at that time. String processing is Google&rsquo;s additional issue. Numerous text files, or web pages, are read and analyzed by Google. This was obviously not good for the developers because it made them less productive.
So Google engineers Robert Griesemer, Rob Pike, and Ken Thompson sketched out some goals for a new language:
Fast Compilation (Efficiency) Less cumbersome code (Simplicity) Unused memory freed automatically (Garbage Collection) Easy-to-write software that does several operations simultaneously (Concurrency) Good support for processor with multiple cores After a couple years of work, Google had created Go: a language that was fast to write code and produced programs that were fast to compile and run. Google built a rich library of string functions into Go, Garbage Collecting makes strings in Go simple to think about, and efficient in ways some other string libraries are not. The project switched to an open source license in 2009. It‚Äôs now free for anyone to use.
If you&rsquo;re developing a command-line tool in Go, you can generate executable files for Windows, MacOS, and Linux using the same source code. If you&rsquo;re building a web server, Go can assist you in efficiently managing multiple simultaneous user connections. Regardless of your project&rsquo;s nature, Go will aid you in making your code easier to maintain.
Let&rsquo;s start with syntax and clean code principles :
Go file layout Now let‚Äôs look at the code and figure out what it actually means‚Ä¶
go Hello World package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello, World&#34;) } Every Go file has three sections:
The package clause Any import statements The actual code Package : A package in Go is a way to organize and structure code into meaningful units, helping with code organization and reusability. It allows control over visibility, promoting encapsulation and dependency management. The main package serves as the entry point for Go programs.
import : Go files almost always have one or more import statements. The import statement is used to bring in external packages that your code relies on. It ensures that your program loads only the necessary packages, making it faster and more efficient than loading everything at once.
actual code : The last part of every Go file is the actual code, which is often split up into one or more functions. A function is a group of code that you call (run) from other places in your program. When a Go program is run, it looks for a function named main and runs that first, which is why we need this function main.
Function : A function is a group of one or more lines of code that you can call (run) from other places in your program.
Below is the code with what it does in comments:
go Hello World // This line says the rest of the code in // this file belongs to the &#34;main&#34; package package main // This says we will be using text-formatting // code from the &#34;fmt&#34; package import &#34;fmt&#34; // The &#34;main&#34; function is special; it gets run // first when your program runs. func main() { // This line displays (&#34;print&#34;) &#34;Hello, World&#34; in // your terminal (or web browser, if you&#39;re using the Go Playground) // // It does this by calling the &#34;Println&#34; function // from the &#34;fmt&#34; package fmt.Println(&#34;Hello, World&#34;) } Note: When a Go program is run, it looks for a function named main and runs that first.
No Semicolons As you can see in our previous program, there are no semicolons to separate statements in Go; we can use semicolons, but it‚Äôs not required (in fact, it‚Äôs generally frowned upon). This design choice was made to enhance code readability and reduce the potential for common programming errors.
Like C, Go&rsquo;s formal grammar uses semicolons to terminate statements, but unlike C, those semicolons do not appear in the source. Instead, the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them.
How does it know when to add semicolons? The rule is: If a line ends with an identifier (for example: words such as int or float64), a basic value such as a number or a string, or certain specific tokens such as
break continue fallthrough return ++ -- ) }
The Go lexer then adds a semicolon after that token when it encounters a newline, which is \\n.
To put it simply, when there&rsquo;s a chance that a newline could end a statement, Go automatically inserts a semicolon.
One consequence of the semicolon insertion rules is that you cannot put the opening brace of a control structure like if, for, switch, or select on the new line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. So write them similar to below:
go if statement if i &lt; f() { g() } not like this:
go bad if statement if i &lt; f() // wrong! { // wrong! g() } Formatting Formatting issues are the most contentious but the least important. People may prefer different formatting styles, so when another developer or person reads the same code, it may take some time for them to grasp if they are not accustomed to the same formatting style. It will be easier if everyone formats their documents the same way.
Go takes an unusual approach and lets the machine take care of most formatting issues. The Go compiler comes with a standard formatting tool called go fmt. This tool reads a program and automatically formats it with consistent indentation, alignment, and comment retention or adjustment to match a standard style.
Next time, whenever you share your code, other Go developers will expect it to be in the standard Go format. With Go, all you have to do is run go fmt.
If you want to try its simple version, head over to the Go playground, write some unformatted code, and hit the format button.
Comments In Go, developers write text annotations within the source code as comments. These annotations are not executed by the program but serve as notes, explanations, or documentation. Comments are essential for providing context, making code more understandable, and documenting code for future reference.
Go provides C-style /* */ block comments and C++-style // line comments.
Single-line comments: Single-line comments start with two slashes // and continue until the end of the line. They are used for adding brief explanations or clarity to a specific line of code. go Single-line comment // This is a single-line comment in Go. var x int // This comment explains the purpose of the variable. Multi-line comments: Multi-line comments are enclosed within /* and */ and can span multiple lines. They are commonly used for documenting larger sections of code, writing package-level documentation, or providing more detailed explanations. go Multi-line comment /* This is a multi-line comment in Go. It can span multiple lines and is useful for providing detailed explanations or comments for larger code blocks. */ Go also has a convention for documenting exported (public) identifiers and packages using special comments, often referred to as &ldquo;comment annotations&rdquo; or &ldquo;comments for the godoc tool&rdquo;. These comments are structured in a way that allows the godoc tool to automatically generate documentation based on them.
For documenting exported identifiers, you can use a comment placed directly before the identifier, starting with the identifier name and a brief description:
go Sample Go Doc Comment // MyFunction is a public function that performs a specific task. func MyFunction() { // Function implementation... } For package-level documentation, you can include a comment at the top of the file:
go Package level doc comment // Package mypackage provides functionality for... package mypackage import &#34;fmt&#34; // ExportedFunction is a function that... func ExportedFunction() { // Function implementation... } To generate documentation from these comments, you can use the godoc command-line tool. Running godoc on your Go code will produce documentation that includes your comments, making it easier for others to understand and use your code. Properly documented code is not only more understandable but also encourages collaboration and code maintenance.
Names Names are as important in Go as in any other language. When coding, we should consider naming variables, functions, arguments, classes, packages, source files, and directories that contain those source files.
According to the book Clean Code by Robert C. Martin, there are some standards for naming:
Choose descriptive and unambiguous names. Make a meaningful distinction. Use pronounceable names. Use searchable names. Replace magic numbers with named constants. Avoid encodings. Don&rsquo;t append prefixes or type information. You can check this points in detail in this blog
Go has one simple set of rules that apply to the names of variables, functions, and types:
A name must begin with a letter and can have any number of additional letters and numbers. The following points determine the visibility of a name (variable, function, and type names) outside a package: If the name of a variable, function, or type begins with a Capital letter, it is considered as Exported and can be accessed from a package outside the current one. Example - As you have seen in the above hello world program. The P in fmt.Println is capitalized: so it can be used from the main package or any other. If the name begins with a Lowercase letter, it is considered Unexported and can only be accessed within the current package. Above are the only rules that are enforced in Go language. But Go Community follows some additional conventions as well:
When naming something in Go, for instance a variable or a function, use CamelCase. This means that if the name has more than one word, start with a lowercase letter for the first word and then capitalize the first letter of each following word without using spaces. For example, topRank and RetryConnection are in CamelCase, which looks like camel humps. If a name&rsquo;s meaning is clear from the context, it&rsquo;s common to use abbreviations such as i for index or max for maximum to keep the code concise and easy to read. MixedCaps The convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multi-word names.
Package Name Good package names make code better. A package‚Äôs name provides context for its contents, making it easier for the developer or user to understand what the package is for and how to use it. The name also helps package maintainers determine what does and does not belong in the package as it evolves. Well-named packages make it easier to find the code you need.
Package Name Guideline To make a Go package easy to use, it&rsquo;s best to give it a short, clear, and meaningful single-word name. Packages typically have lowercase names without under_scores or mixed capital letters. These names are often simple nouns, for example:
time (provides functionality for measuring and displaying time) list (implements a doubly linked list) http (provides HTTP client and server implementations) Below are examples of bad naming styles in Go:
computeServiceClient priority_queue Abbreviate judiciously. Package names may be abbreviated when the abbreviation is familiar to the programmer. Widely used packages often have compressed names:
strconv (string conversion) syscall (system call) fmt (formatted I/O) Note:- If abbreviating a package name makes it ambiguous or unclear, don‚Äôt do it.
Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as &quot;encoding/base64&quot; but has the name base64, not encoding_base64 and not encodingBase64.
Another short example is once.Do; once.Do(setup) reads well and would not be improved by writing once.DoOrWaitUntilDone(setup). Long names don&rsquo;t automatically make things more readable. A helpful doc comment can often be more valuable than an extra-long name.
Interface Names By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun; Reader, Writer, Formatter, CloseNotifier etc.
Variable Declaration In Go, a variable is a piece of storage containing a value. You can give a variable a name by using a variable declaration. Just use the var keyword, followed by the desired name and the type of values the variable will hold.
Variable declaration syntax:
var name string
var :- A keyword. name :- A variable name that you want to access in your program. string :- Any datatype that the variable will hold data for. (Go-supported datatype) Once you declare a variable, you can assign any value of that type to it with the = sign.
var name string = &quot;Jerry&quot;
You can assign values to multiple variables in the same statement. Just place multiple variable names on the left side of =, and the same number of values on the right side, separated with commas (,).
Syntax for assigning multiple variables at once:
var length, width float64 = 1.2, 2.4
You can assign new values to existing variables, but they need to be values of the same type, for example: when you assign an int variable value to a string type variable. Go‚Äôs static typing ensures you don‚Äôt accidentally assign the wrong kind of value to a variable.
Short Variable Declaration As we saw in the above section, we can declare variables and assign them values on the same line. But if you know what the initial value of a variable is going to be as soon as you declare it, it‚Äôs more typical to use a short variable declaration. Instead of explicitly declaring the type of the variable and later assigning it with =, you do both at once using :=.
Here are our previous examples with short variable declarations :
name := jerry instead of var name string = &quot;Jerry&quot; length, width := 1.2, 2.4 instead of var length, width float64 = 1.2, 2.4 There‚Äôs no need to explicitly declare the variable‚Äôs type; the type of the value assigned to the variable becomes the type of that variable.
Because short variable declarations are so convenient and concise, they‚Äôre used more often than regular declarations. You‚Äôll still see both forms occasionally, though, so it‚Äôs important to be familiar with both.
Thanks!!! In this blog, we&rsquo;ve delved into Go&rsquo;s intriguing history, exploring its origins and essential conventions such as formatting, comments with the godoc tool, and naming guidelines. We also demystified the absence of semicolons in Go and how they are automatically inserted.
If you found this blog helpful or discovered something new, please consider sharing it with your connections who may benefit from a clearer understanding. If you&rsquo;ve spotted any errors or have additional insights, please don&rsquo;t hesitate to leave a comment below. Let&rsquo;s engage in discussions and learn together.
Once again, a big thank you for joining me on this journey. ü•≥
References Head First GO - Jay McGavren Effective Go - Go Doc Clean Code - Robert C. Martin `,url:"/posts/go-basics-and-a-dash-of-clean-code/"},"/posts/lets-go/":{title:"Let's Go",tags:["start","beginning","blog"],categories:[],keywords:["programming","blogs","first blog","non-technincal","golang"],content:`Begin This is the new beginning and also my second blog, which is also a non-technical blog (first blog). I have decided to start writing blogs so that I can share my thoughts and knowledge and improve my writing skills. I will be writing blogs about mostly technical stuff and sometimes non-technical stuff. In technical blogs, I will cover whatever research I have done, and while doing research, I will keep my notes in the Notes section.
Plan and Present As of now, I don‚Äôt have a full plan for what I am going to write, which topics I will cover, or where it will go. But I remember a quote that says to go with the flow and be more concerned with the journey than the destination.
&ldquo;A good traveler has no fixed plans, and is not intent on arriving.&rdquo; - Lao Tzu
To start with, I will be writing blogs about Golang, which I am currently obsessed with.
As said, I am currently obsessed with Golang, like how it internally works and all. I will start with its basics, and as I go along with my research, I will dig down into how Golang works internally. I am more curious to do research on its internal workings and its concurrency. I will try to explain all the things in an easy way (I hope so üò¨).
As I go with blogs, I will create YouTube videos for the same on my channel. I have lots of project ideas that I will create as an example, and if it is an interesting idea or helpful, I will make it open-source, or you guys can start contributing your ideas to the project.
From my contribution, I have remembered how I struggled with starting to contribute to open-source projects. So definitely, I will write a blog about how to get started with open source. Also,share my experience with it. As of now,I am contributing to vscode-extension for ORY organization, which mostly provides solutions in the areas of authentication, authorization, access control, and zero-trust networking with their open-source projects. I will create a new tab where I can keep track of the ideas.
So my plan will be, in short:
Research on the topic Add to Notes Write blog Make YouTube Videos Let&rsquo;s Go Let us begin this journey and learn as we go. The start may not be great, but you have to start to be great.
If you are interested, I created a track 7 years ago called Let&rsquo;s Go
`,url:"/posts/lets-go/"},"/notes/go/":{title:"Go",tags:["golang","notes"],categories:["Go"],keywords:["programming","go","go notes","technical","golang","golang notes","golang basics","golang syntax"],content:` Go is a programming language that focuses on simplicity and speed. It&rsquo;s simpler than other languages, so it&rsquo;s quicker to learn. And it lets you harness the power of today&rsquo;s multicore computer processor, so your programs run faster.
History of Go Back in 2007, the search engine Google had a problem. They had to maintain programs with millions of line of code. Before they could test new changes, they had to compile the code into runnable form, a process which at the time took the better part of an hour. Needless to say, this was bad for developer productivity.
So Google engineers Robert Griesemer, Rob Pike, and Ken Thompson sketched out some goals for a new language:
Fast Compilation Less cumbersome code Unused memory freed automatically (garbage collection) Easy-to-write software that does serval operations simultaneously (concurrency) Good support for processor with multiple cores After a couple years of work, Google had created Go: a language that was fast to write code for and produced programs that were fast to compile and run. The project switched to an open source license in 2009. It&rsquo;s now free for anyone to use.
If you&rsquo;re writing a command-line tool, Go can produce executable files for Windows, MacOS, and Linux, all from the same source code. If you&rsquo;re writing a web server, it can help you handle many users connecting at once. And no matter what you&rsquo;re what you&rsquo;re writing, it will help you ensure that your code is easier to maintain.
Syntax Basics Go Playground The easiest way to try Go is to visit Go Playground in your web browser. It is simple editor where you can enter Go code and run it on their servers. The result is displayed right there in your browser.
Note: Go Playground requires stable internet connection. If you don&rsquo;t, see Install Go on your system.
Let&rsquo;s try out play ground:
Open Go Playground in your browser. There will be hello world program already written. Click the Format button, which will automatically reformat your code according to Go conventions. Click the Run button. You should see &ldquo;Hello, World!&rdquo; displayed at the bottom of the screen.
Congratulations, you&rsquo;ve just run your first Go programü•≥!
Go file layout Now let&rsquo;s look at the code and figure out what it actually means&hellip;
go Hello World package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello, World&#34;) } Every Go file has three sections:
The package clause Any import statements The actual code Package : A package is a collection of code that all does similar things, like formatting strings or drawing images. The package clause gives the name of the package that this file&rsquo;s code will become a part of. In this case, we use the special package main, which is required if this code is going to be run directly (usually from the terminal). import : Go files almost always have one or more import statements. Each file needs to import other packages before its code can use the code those other packages contain. Loading all the Go code on your computer at once would result in a big, slow program, so instead you specify only the package you need by importing them. actual code : The last part of every Go file is the actual code, which is often split up into one or more functions. A function is a group of code that you call (run) from other places in your program. When a Go program is run, it looks for a function named main and runs that first, which is why we need this function main. Below is the code with what it does in comments:
go Hello World // This line says the rest of the code in // this file belongs to the &#34;main&#34; package package main // This says we will be using text-formatting // code from the &#34;fmt&#34; package import &#34;fmt&#34; // The &#34;main&#34; function is special; it gets run // first when your program runs. func main() { // This line displays (&#34;print&#34;) &#34;Hello, World&#34; in // your terminal (or web browser, if you&#39;re using the Go Playground) // // It does this by calling the &#34;Println&#34; function // from the &#34;fmt&#34; package fmt.Println(&#34;Hello, World&#34;) } Function : A function is a group of one or more lines of code that you can call (run) from other places in your program. Note: When a Go program is run, it looks for a function named main and runs that first.
No Semicolons As you can see in our program there are no semicolons to separate statements in Go, we can use semicolons but it&rsquo;s not required (in fact, it&rsquo;s generally frowned upon).
Like C, Go&rsquo;s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them.
If you want to know more how it works you check Go&rsquo;s official doc https://go.dev/doc/effective_go#semicolons
Formatting Formatting issues are the most contentious but the least important. People may prefer different formatting styles, thus when another developer or person reads the same code it may take some time for him to grasp if he is not accustomed to the same formatting style. It will be easier if everyone formats their documents in the same way.
With Go we take an unusual approach and let the machine take care of most formatting issues. The Go compiler comes with a standard formatting tool, called go fmt. The go fmt program reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments.
Next time whenever you share your code, other Go developers will expect it to be in the standard Go format. With Go all you have to do is run go fmt.
If you want to try its simple version, head over to the Go playground, write some buggy or unformatted code, and hit the format button.
Comments Go provides C style /* */ block comments and C++ style // line comments. Most block comments appear as package comments but are useful within an expression or to disable large blocks of code; Otherwise usually line comments are used.
Comments that appear before a top-level declaration, with no intervening newlines, are considered to document the declaration itself. For example: In the above Hello World programme with comments, all comments will be used in Go Documents. These doc comments are the primary documentation for given Go package or command.
For more about doc comments, see Go Doc Comments.
Names Names are as important in Go as in any other language. Go has one simple set of rules that apply to the names of variables, functions, and types:
A name must begin with letter, and can have any number of additional letters and numbers.
The visibility of a name outside a package is determined by below points:
If the name of a variable, function, or type begins with a Capital letter, it is considered Exported and can be accessed from packages outside the current one. Example - As you have seen in above hello world program. The P in fmt.Println is capitalized: so it can be used from the main package or any other. If the name begins with a Lowercase letter, it is considered Unexported and only be accessed within the current package. Above the only rules enforced by the language. But the Go community follows some additional conventions as well:
If a name consists of multiple words, each word after the first should be capitalized, and they should be attached together without spaces between them, like this: topRank, RetryConnection&hellip; This style is often called Camel Case because the capitalized letter look like the humps of a camel.
When the meaning of a name is obvious from the context, the Go community&rsquo;s convention is to abbreviate it: to use i instead of index, max instead of maximum&hellip;
MixedCaps The convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names.
Package Names Good package names make code better. A package&rsquo;s names provides context for its contents, making it easier for developer/user to understand what the package is for and how to use it. The name also helps package maintainers determine what does and does not belong in the package as it evolves. Well-named packages make it easier to find the code you need.
Guideline It&rsquo;s helpful if everyone using the package can the same name to refer to its contents, which implies that the package name should be good: short, concise, evocative. By convention, packages are given lower case, single-word names; there should be no need for under_scores or mixedCaps. They are often simple nouns, such as:
time (provides functionality for measuring and displaying time) list (implements a doubly linked list) http (provides HTTP client and server implementations) Below are example for bad naming styles in Go:
computeServiceClient priority_queue Abbreviate judiciously. Package names may be abbreviated when the abbreviation is familiar to the programmer. Widely-used packages often have compressed names:
strconv (string conversion) syscall (system call) fmt (formatted I/O) Note:- If abbreviating a package name makes it ambiguous or unclear, don‚Äôt do it.
Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as &quot;encoding/base64&quot; but has name base64, not encoding_base64 and not encodingBase64.
Another short example is once.Do; once.Do(setup) reads well and would not be improved by writing once.DoOrWaitUntilDone(setup). Long names don&rsquo;t automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name.
Interface Names By convention, one-method interfaces are named by the method name plus and -er suffix or similar modification to construct an agent noun; Reader, Writer, Formatter, CloseNotifier etc.
Declaration Variables In Go, a variable is a piece of storage containing a value. You can give a variable a name by using a variable declaration. Just use the var keyword followed by the desired name and the type of values the variable will hold.
Variable declaration syntax:
var name string
var :- It is a keyword. name :- It will be a variable name that you want to access in your programme. string :- It will be any datatype that the variable will hold data for. (Go-supported datatype) Once you declare a variable, you can assign any value of that type to it with = sign.
var name string = &quot;Jerry&quot;
You can assign values to multiple variables in the same statement. Just place multiple variable names on the left side of =, and the same number of values on the right side, separated with commas (,).
Syntax for assign multiple variables at once:
var length, width float64 = 1.2, 2.4
You can assign new values to existing variables, but they need to be values of the same type like you can&rsquo;t assign int variable value to string type variable. Go‚Äôs static typing ensures you don‚Äôt accidentally assign the wrong kind of value to a variable.
Short Variable Declaration As we seen in the above section we can declare variables and assign them values on the same line. But if you know what the initial value of a variable is going to be as soon as you declare it, it‚Äôs more typical to use a short variable declaration. Instead of explicitly declaring the type of the variable and later assigning to it with =, you do both at once using :=.
Here are our previous examples with short variable declaration :
name := jerry instead of var name string = &quot;Jerry&quot; length, width := 1.2, 2.4 instead of var length, width float64 = 1.2, 2.4 There‚Äôs no need to explicitly declare the variable‚Äôs type; the type of the value assigned to the variable becomes the type of that variable.
Because short variable declarations are so convenient and concise, they‚Äôre used more often than regular declarations. You‚Äôll still see both forms occasionally, though, so it‚Äôs important to be familiar with both.
Pointers Functions A function is a group of statements that together perform a task. Function can be used to:
Reuse code in multiple places. Make code more organized and readable. Hide implementation details. Improve code performance. Functions are declared using the func keyword, followed by the function name, a list of parameters in parentheses (), and a block of code. The function body is enclosed in curly braces ({ and }). A function can take zero or more arguments.
Syntax for function in Go: func funcName(var1 dataType, var2 dataType,... varN dataType) returnType {}
Creating Function and Calling Function Let&rsquo;s create a sample addition program which will contains function with name add() it will take 2 arguments x and y. Which will be int type and return int (Don&rsquo;t worry we will check return and data types next sections.).
go Addition Function package main import &#34;fmt&#34; func add(x, y int) int { return x &#43; y } func main() { fmt.Println(add(15, 10)) } In the above Addition Function program we have two functions. The first is main(), which doesn&rsquo;t take any arguments (arguments are passed inside rounded brackets ()). The second function is our add function, which you can see we have started with the func keyword to declare a function, followed by the function name add(), and we have passed two arguments x and y, which are type of int. When two or more consecutively named function parameters or arguments share a type, you can omit the type from all but the last.
In the above example, we shortened:
x int, y int to x, y int
The function is returning int data type, which is single value, with return statement statement of x + y, which is an addition of numbers.
To call this function, we need to type the function name (add in this case) and a pair of parentheses with arguments separated by a comma (,) in our case, which is 15, 10.
A parameter is a variable, local to a function, whose value is set when the function is called. When the function is run, each parameter will be se to a copy of the value in the corresponding arguments.
If you check the above program Println is also a function. Let&rsquo;s break down the structure of fmt.Println() and see what is happening here.
fmt. :- It is an package which contain multiple function. Println :- Println is function name which resides in fmt package. To use Println package should be imported then only we can access function it offers. () :- By using parentheses we are executing the function. If the function takes a number of arguments and we don‚Äôt pass any or provide too few or too many, it will give you an error message saying how many arguments were expected, and you will need to fix your code.
Function parameters receive copies of the arguments As we mentioned, when you call a function that has parameters declared, you need to provide arguments to the call. The value in each argument is copied to the corresponding parameter variable. It is also called pass-by-value.
Go is a &ldquo;pass-by-value&rdquo; language; function parameters receive a copy of the arguments from the function call.
This is fine in most cases. But if you want to pass a variable&rsquo;s value to a function and have it change the value in some way, you&rsquo;ll run into trouble. The function can only change the copy of the value in it&rsquo;s parameter, not the original. So any changes you make within the function won&rsquo;t be visible outside it!
For example:
Pass-by-value Now, we wanted to move the statement that prints the addition value from the add function back to the function that calls it (in this case main). It won&rsquo;t work, because add function only alters its copy of the value. In the calling function, when we try to print, we&rsquo;ll get the original value, not the addition one!
Pass-by-value Printing outside add function There is a way to allow a function to alter the original value of variable holds, rather than a copy. We do this using pointers which also called as &ldquo;pass-by-reference&rdquo;.
Multiple Return Value One of Go&rsquo;s unusual features is that functions and methods can return multiple values. This feature is quite useful in various situations where you need to return more than one piece of information from a function. Multiple return values allow you to efficiently handle errors, return status code, or return additional context information along with the primary result.
Below is Division program which return multiple values like quotient, remainder :
go Division package main import ( &#34;fmt&#34; ) func divideAndRemainder(dividend, divisor int) (int, int) { quotient := dividend / divisor remainder := dividend % divisor return quotient, remainder } func main() { quotient, remainder := divideAndRemainder(10, 3) fmt.Printf(&#34;Quotient: %d, Remainder: %d\\n&#34;, quotient, remainder) } In the above example, the divideAndRemainder function takes two integer parameters, dividend and divisor. It calculates the quotient and remainder of the division operation and returns both values as tuple (or pair) of integers. In Go, you specify the return types in parentheses immediately after the function signature. In below declaration (int, int) is returning pair of integers in function return value.
func divideAndRemainder(dividend, divisor int) (int, int) {}
When you call the divideAndRemainder function in the main function, you can capture both return values (quotient and remainder) and use them as needed.
Named Result Parameters Named Result Parameters allow us to declare names from the return values of a function in it&rsquo;s signature. Named result parameters are particularly useful for improving the readability and documentation of a code. They make it clear what each return value represents and can be especially helpful in functions with multiple return values.
go Division with Named Result Parameters package main import &#34;fmt&#34; func divideAndRemainder(dividend, divisor int) (quotient int, remainder int) { quotient = dividend / divisor remainder = dividend % divisor return } func main() { q, r := divideAndRemainder(10, 3) fmt.Printf(&#34;Quotient: %d, Remainder: %d\\n&#34;, q, r) } In this example, the divideAndRemainder function has named result parameters quotient and remainder ((quotient int, remainder int)). Inside the function body, you assign values to these variables, and you don&rsquo;t need to use the return statement explicitly. Go will automatically return the values of quotient and remainder when the function exits.
Benefits of using named result parameters:
**_Documentation and clarity_**: It provide self-documentation for the function, making it clear what each return value represents. This can improve code readability and maintainability. **_Simplify return statement_**: You don&rsquo;t need to explicitly list the return values in the return statement. This simplifies the code and reduces redundancy. **_Avoid variable shadowing_**: When you use named result parameters, you can avoid variable shadowing issues that may occur if you redeclare the same variable names in a nested block. **_Facilitate readability in complex function _**: In functions with many return values or complex logic, using named result parameters can make it easier to understand the meaning of each return value. Note:- Named result parameters are implicitly declared as local variables within the function. You can assign values to them directly, and they will be returned when the function exits. However,you cannot use the := short declaration operator to declare and assign values to named result parameters withing the same line; you should use the = assignment operator.
Defer In Go, the defer statement is used to schedule a function call to be executed just before the surrounding function returns. It allows you to ensure that certain cleanup or finalization tasks are performed regardless of how the function exits, whether it&rsquo;s due to normal execution or an error.
How defer statement works in Go:
**_Deferred functions are executed in reverse order_**: When you use defer to schedule a function call, Go adds it to a stack. The deferred functions are executed in reverse order, meaning the last scheduled function will be executed first, and so on. This behavior is useful when you need to reverse some action or cleanup resources. **_Deferred functions capture their arguments at the time of the defer statement_**: If you pass arguments to a deferred function, those arguments are evaluated immediately, and their values are captured at the time of the defer statement, not at the time the function is executed. This can lead to some interesting behavior in cases where the values of variables change before the function executes. A simple example to illustrate how defer works:
go Defer working package main import ( &#34;fmt&#34; ) func main() { defer fmt.Println(&#34;This will be executed last&#34;) defer fmt.Println(&#34;This will be executed second&#34;) fmt.Println(&#34;This will be executed first&#34;) } In this example, when the main function is executed, it first prints &ldquo;This will be executed first,&rdquo; then schedules the two fmt.Println functions using defer. These deferred functions will be executed in reverse order when the main function is about to return.
In practice, you often use defer for resource cleanup, like closing files, releasing locks, or other cleanup tasks, to ensure that these tasks are performed even if there&rsquo;s an early return or an error condition.
Methods A function is a standalone piece of code that can be called by other parts of your program.
A method is a function that is associated with a specific type or struct.
The term method came up with object-oriented programming. In an OOP language (like C++ for example) you can define a class which encapsulates data and functions which belongs together. Those functions inside a class are called methods and you need an instance of that class to call such a method.
In Go, the terminology it is basically the same, although Go isn&rsquo;t an OOP language in the classical meaning. A function which takes a receiver is usually called a method (probably just because people are still used to the terminology of OOP).
So, For example:
go Function func MyFunction(a, b int) int { return a &#43; b } // Usage: // MyFunction(1, 2) but
go Method type MyInteger int func (a MyInteger) MyMethod(b int) int { return a &#43; b } // Usage: // var x MyInteger = 1 // x.MyMethod(2) Data Structures Array An array is a collection of values that all share the same type. Think of it like one of those pill boxes with compartments &ndash; you can store and retrieve pills from each compartment separately, but it&rsquo;s also easy to transport the container as a whole.
The values an array holds are called its elements. You can have an array of string, booleans, or an array of any other Go type (even an array of array). You can store an entire array in a single variable, and then access any element within the array that you need.
An array holds a specific number of elements, and it cannot grow or shrink. To declare a variable that holds an array you need to follow below syntax:
var myArray [4]string
var: Keyword to declare variable. myArray: Variable name which holds array. [4]string: []: In this brackets you specify how much data array should hold. Like in above example [4] it will hold 4 elements. datatype: Which type of data it will store is mentioned here. for example string or int. Elements in an array are numbered, starting with 0. An element&rsquo;s number is called its index.
If you wanted to make an array with the names of people. for example, the first name would be assigned to index 0, the second name would be at 1, and so forth. The index is specified in square brackets.
go Create Array of Names var names [5]string // Create an array of five strings. names[0] = &#34;Goku&#34; // Assign a value to the first element. names[1] = &#34;Vegeta&#34; // Assign a value to the second element. names[2] = &#34;Gohan&#34; // Assign a value to the third element. fmt.Println(names[0]) // Print the first element. fmt.Println(names[1]) // Print the second element. // Output: Goku Vegeta If you doesn&rsquo;t assign a value to names[0] and try to print. It will show empty string lets see why.
Default values in arrays As with variables, when an array is created, all the values it contains are initialized to the zero value for the type that array holds. So an array of int values is filled with zeros by default and same will be for string but instead of zeros it will be empty string.
Zero/default values can make it safe to manipulate an array element even if you haven&rsquo;t explicitly assigned a value to it. For example, here we have an array of integer counters. We can increment any of them without explicitly assigning a value first, because we know they will all start from 0.
go Zero value manipulation var counters [3]int counters[0]&#43;&#43; // Increment the first element from 0 to 1. counters[0]&#43;&#43; // Increment the first element from 1 to 2. counters[1]&#43;&#43; // Increment the third element from 0 to 1. fmt.Println(counters[0], counters[1], counters[2]) 2 0 1 / | \\ / | Has been incremented once / Still at its zero value Has been incremented twice Note:- When an array is created, all the values it contains are initialized to the zero value for the type the array holds.
Okay, but how can assign default values like we do in python and other languages?
Array literals If you know in advance what values an array should hold, you can initialize the array with those values using an array literal. An array literal starts just like an array type, with the number of elements it will hold in square brackets, followed by the type of its elements. This is followed by a list in curly braces of the initial values each element should have. The element values should be separated by commas ,.
[3]int{7, 21, 5}
[3]: Number of elements array will hold. int: Type of elements array will hold. {data, comma, separated} : Comma-separated list of array values. Let&rsquo;s our previous example using array literals, instead of assigning values to the array elements one by one:
var names [4]string = [4]string{&quot;Goku&quot;, &quot;Vegeta&quot;, &quot;Gohan&quot;}
Using an array literal also allows you to do short variable declaration with :=.
names = [4]string{&quot;Goku&quot;, &quot;Vegeta&quot;, &quot;Gohan&quot;}
If you have array string with sentences as value:
text := [3]string{&#34;This is a series of long strings&#34;, &#34;which would be awkward to place&#34;, &#34;together on a single line&#34;} As you see above it will be hard to read if item grow it will be in single line to make it more readable we can break this in multiline as shown below:
text := [3]string{ &#34;This is a series of long strings&#34;, &#34;which would be awkward to place&#34;, &#34;together on a single line&#34;, } But here is catch which you will have to keep in mind when you break it in multiline it should end with , else you will get error/run it problems.
Data Types Conditionals and Loops `,url:"/notes/go/"},"/notes/system-design/":{title:"System Design",tags:["system design","notes"],categories:["System Design"],keywords:["programming","system design","database","scaling"],content:` Scale From Zero To Millions of Users In this we will see that system that support single user and gradually scale it up to serve millions of users.
Single Server Setup Whatever we are developing/building alway start with a single basic step and this also goes same for complex systems. To start with something single, we will be running everything on a single server. below is figure of single server setup where it will be running: web, app, database, cache, etc.
Single Web Server Working `,url:"/notes/system-design/"},"/notes/oauth2/":{title:"OAuth2 and OpenID Connect",tags:[],categories:[],keywords:[],content:`OAuth 2.0 OAuth 2.0 is an open authorization protocol, which enables application to access each other&rsquo;s data. OAuth 2.0 does not share password data but instead uses authorization tokens to prove an identity between consumers and service providers. In simple term it uses authorization process to jump from one service to another without tapping in a new username and password. If you&rsquo;re logged into Google and used those credntials for any app (Sign with Google), you&rsquo;ve used OAuth.
OAuth2 is the industry-standard protocol that enables secure machine-to-machine communication and grants limited access to data and services on behalf of users. The specification also covers delegated access to client types such as browser-based, server-side web, native/mobile apps, and connected devices.
OAuth was originally designed for applications to get access to API&rsquo;s (All they need to ability to access the API). OAuth doesn&rsquo;t communicate with user information. OpenID communicate with user information.
OAuth 2.0 Actors OAuth 2.0 has different actors defined in the authentication and authorization process. These actors work together to ensure that the user&rsquo;s information is kept secure and that the application only accesses the information that the user has explicitly granted permission for.
OAuth2 Actors `,url:"/notes/oauth2/"},"/notes/regex/":{title:"",tags:[],categories:[],keywords:[],content:`http://regextutorials.com/
`,url:"/notes/regex/"},"/notes/":{title:"note",tags:[],categories:[],keywords:[],content:"",url:"/notes/"}}</script><script src=/js/lunr.min.js></script>
<script src=/js/search.js></script><footer class=footer><div class=footer__inner><a href=/index.xml class=rss-link target=_blank><img src=/img/svgs/rss.svg alt=rss height=30px width=30px></a><div class=copyright><span>¬© 2023 Rushi Panchariya</span>
<span>:: All rights reserved. üöÄ</span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>